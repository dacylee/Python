https://programmers.co.kr/learn/courses/30/lessons/43165

<문제>

주어진 정수들을 이용해 타겟 넘버를 만든다.
그 방법의 수를 return 해야한다. 
주어진 정수(numbers)와 타겟 넘버(target)은 매개변수로 주어진다.
ex) [1,1,1,1,1] -> 3으로 만들기 위해선
    -1 + 1 + 1 + 1 + 1 = 3
    +1 - 1 + 1 + 1 + 1 = 3
    +1 + 1 - 1 + 1 + 1 = 3
    +1 + 1 + 1 + 1 - 1 = 3

<문제 풀이>

타겟 넘버가 그래프 문제인 이유: 다음 인덱스에 해당하는 numbers 원소를 더하거나 뺀 값을 방문해야 함 

numbers = [1,1,1,1,1]

1 -> 2 -> 3   
       -> 1 
  -> 0 -> 1  
       -> -1
       

알고리즘(DFS 사용):
1) dfs(1) 내부에서 dfs(2), dfs(0) 호출
2) dfs(2) 내부에서 dfs(3), dfs(1) 호출
... 

1 -> 2 -> 3   
       -> 1 
  -> 0 -> 1  
       -> -1
       
* 이때 index 값을 함께 전달해야 함: dfs(값, index)

<코드>

def solution(numbers, target):
    n = len(numbers)
    answer = 0
    def dfs(idx, result):
        if idx == n: # 인덱스가 일치하고
            if result == target: # 타겟 넘버가 나왔을 때
                nonlocal answer
                answer += 1 # 더해줌
            return
        else:
            dfs(idx+1, result+numbers[idx])
            dfs(idx+1, result-numbers[idx])
    dfs(0,0)
    return answer

print(solution([1,1,1,1,1], 3))

# 혼자 힘으로 풀지 못해서 구글링한 후 알고리즘을 공부했다.
# 원하는 값을 가진 노드(인덱스, 타겟 넘버)가 나올 때까지 계속해서 탐색하는 방식의 풀이다.
# 재귀함수를 활용한 dfs를 사용했다. 
# dfs에 (0,0)부터 넣은 뒤 (그래야 numbers의 원소들의 인덱스에 맞춰서 계산 가능하니까)
# 그 다음 노드에 인덱스를 더해주고 결과값은 + / - 해줘서 노드를 새로 만들어 호출해오는 방식이다.
