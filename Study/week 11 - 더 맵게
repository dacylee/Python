# 문제 링크: https://programmers.co.kr/learn/courses/30/lessons/42626
문제 해석 
모든 음식의 스코빌 지수를 k 이상
스코빌 지수가 낮은 두 개의 음식의 경우엔 새로운 음식으로 만듦:
섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 *2)
모든 음식의 스코빌 지수가 k 이상이 될 때까지 반복해 섞음 

가장 낮은 수 두 개는 k 이상이 될 때까지 공식대로 곱하고 더해줘서 모든 수를 k 이상으로 만들어줘야 함.

<힙 자료구조>
힙: 특정한 규칙을 가지는 트리로 최댓값과 최솟값을 찾는 연산을 빠르게 하기 위해 고안된 완전이진 트리를 기본으로 함.

힙 property: A가 B의 부모 노드이면 A의 키값과 B의 키값 사이에는 대소 관계 성립

최소 힙: 부모 노드의 키값이 자식 노드의 키값보다 항상 작은 힙 (파이썬의 heapq에선 최소힙만 지원됨)
최대 힙: 부모 노드의 키값이 자식 노드의 키값보다 항상 큰 힙 

이 때문에 힙에서 가장 낮은/높은 우선순위를 가지는 노드가 루트에 오게 됨
* 형제 노드 사이에는 대소 관계가 정해지지 않음 

heapq 모듈은 heapq(priority queue) 알고리즘 제공함
리스트를 최소 힙처럼 다룰 수 있도록 함
이미 생성해둔 리스트가 있다면 heapify 함수를 통해 힙 자료형으로 변환 가능 
  ex): heap2 = [50, 10, 20]
       heapq.heapify(heap2)
       print(heap2)

힙 함수 
heapq.heappush(heap, item): item을 heap에 추가
heapq.heappop(heap): heap에서 가장 작은 원소를 pop & return
heapq.heapify(x): 리스트 x를 즉각적으로 heap으로 변환함 / 오름차순 정렬과 비슷함 

---------------------------------------
문제 풀이 1회차 

import heapq
smlst = []
heapq.heapify(scoville) # 힙 자료형으로 변환
for i in range(scoville):
  if i < K:
   smlst = heapq.heappop(scoville): # scoville에서 가장 작은 원소 pop & return
   smlst2 = heapq.heappop(scoville)
   new_sco = smlst + (smlst2 * 2)
   heapq.heappush(scoville, new_sco)
   count += 1
   return(count)
   break

---------------------------------------
문제 풀이 2회차 

import heapq

def solution(scoville, K):
    heap = []
for i in scoville:
    heapq.heappush(heap, i) # scoville -> 힙 자료형으로 변환
while heap[0] < K:
    smlst = heapq.heappop(scoville): # scoville에서 가장 작은 원소 pop & return
    smlst2 = heapq.heappop(scoville)
    new_sco = smlst + (smlst2 * 2)
    heapq.heappush(scoville, new_sco)
    count += 1
    return(count)
    
---------------------------------------
문제 풀이 3회차 

import heapq

def solution(scoville, K):
    heap = []
    count = 0
    for i in range(scoville):
        heapq.heappush(heap, i) # scoville의 값들을 heap에 넣어줌 
        while heap[0] < K: # heap의 가장 작은 값이 k 보다 작을 때 
            smlst = heapq.heappop(heap) # scoville에서 가장 작은 원소 pop 
            smlst2 = heapq.heappop(heap)
            new_sco = smlst + (smlst2 * 2) # 계산하기 
            heapq.heappush(heap, new_sco)
            count += 1

        else:
            print(count) 
** 해결해야 하는 것 ** k를 넘지 못할 때 -1 return 해야 함 

------------------------------------------

해결 못해서 구글링 함

# 문제 풀이 출처: https://latte-is-horse.tistory.com/137

from heapq import *

def solution(scoville, K):
    count = 0
    heapify(scoville) # heapify 사용해서 리스트를 힙 배열로 바꿈 
    while scoville[0] < K and len(scoville) > 1: # scoville의 값이 하나 이상일 때만 계산할 수 있음
        num1 = heappop(scoville)
        num2 = heappop(scoville)
        heappush(scoville, num1 + num2 * 2)
        count += 1
    return count if scoville[0] >= K else -1 # return count  # 전부 k이상일 경우는 count, 아니면 -1을 return

**  문제를 못 푼 이유:  
  1) K 이상을 맞추기 위해 값을 계속 더하다 보면 결국 하나의 값만 남게 된다.
     그래서 K를 넘지 못하는 경우는 scoville[0] < K and len(scoville) = 1인 경우다. 
  
  2) return 문과 print 함수의 차이:
     예시 ->
     def f1(x):
      a=3
      b=5
      y=a*x+b
      return y
     c = f1(10)
     print(c) # 35
    
    def f2(x):
      a=3
      b=5
      y=a*x+b
      print(y)
      
    d = f2(10) # 35
    print(d) # None
     
    return이 아닌 print를 사용하면 함수를 호출하는 것만으로도 값이 출력됨 
          
