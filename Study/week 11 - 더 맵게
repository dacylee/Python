# 문제 링크: https://programmers.co.kr/learn/courses/30/lessons/42626
문제 해석 
모든 음식의 스코빌 지수를 k 이상
스코빌 지수가 낮은 두 개의 음식의 경우엔 새로운 음식으로 만듦:
섞은 음식의 스코빌 지수 = 가장 맵지 않은 음식의 스코빌 지수 + (두 번째로 맵지 않은 음식의 스코빌 지수 *2)
모든 음식의 스코빌 지수가 k 이상이 될 때까지 반복해 섞음 

가장 낮은 수 두 개는 k 이상이 될 때까지 공식대로 곱하고 더해줘서 모든 수를 k 이상으로 만들어줘야 함.

<힙 자료구조>
힙: 특정한 규칙을 가지는 트리로 최댓값과 최솟값을 찾는 연산을 빠르게 하기 위해 고안된 완전이진 트리를 기본으로 함.

힙 property: A가 B의 부모 노드이면 A의 키값과 B의 키값 사이에는 대소 관계 성립

최소 힙: 부모 노드의 키값이 자식 노드의 키값보다 항상 작은 힙 
최대 힙: 부모 노드의 키값이 자식 노드의 키값보다 항상 큰 힙 

이 때문에 힙에서 가장 낮은/높은 우선순위를 가지는 노드가 루트에 오게 됨
* 형제 노드 사이에는 대소 관계가 정해지지 않음 

heapq 모듈은 heapq(priority queue) 알고리즘 제공함
리스트를 최소 힙처럼 다룰 수 있도록 함
이미 생성해둔 리스트가 있다면 heapify 함수를 통해 힙 자료형으로 변환 가능 
  ex): heap2 = [50, 10, 20]
       heapq.heapify(heap2)
       print(heap2)

힙 함수 
heapq.heappush(heap, item): item을 heap에 추가
heapq.heappop(heap): heap에서 가장 작은 원소를 pop & return
heapq.heapify(x): 리스트 x를 즉각적으로 heap으로 변환함

import heapq
smlst = []
heapq.heapify(scoville) # 힙 자료형으로 변환
for i in range(scoville):
  if i < K:
   smlst = heapq.heappop(scoville): # scoville에서 가장 작은 원소 pop & return
   smlst2 = heapq.heappop(scoville)
   new_sco = smlst + (smlst2 * 2)
   heapq.heappush(scoville, new_sco)
   count += 1
   return(count)
   break

---------------------------------------
import heapq

def solution(scoville, K):
    heap = []
for i in scoville:
    heapq.heappush(heap, i) # scoville -> 힙 자료형으로 변환
while heap[0] < K:
    smlst = heapq.heappop(scoville): # scoville에서 가장 작은 원소 pop & return
    smlst2 = heapq.heappop(scoville)
    new_sco = smlst + (smlst2 * 2)
    heapq.heappush(scoville, new_sco)
    count += 1
    return(count)
