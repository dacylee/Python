문제 링크: https://programmers.co.kr/learn/courses/30/lessons/42586

<문제 해석>
1. 기능은 진도가 100%일 때 서비스에 반영됨
2. 각 기능의 개발 속도는 모두 달라서 순서와 상관 없음.
3. 뒤에 있는 기능은 앞에 있는 기능보다 먼저 개발 되더라도 먼저 배포될 수 없음.
4. 배포는 하루 끝에 한 번만 이뤄짐. 

입력: progresses (기능 순서대로 주어짐) / speed (기능 개발 속도)

<문제 풀이>

1. 첫 번째 기능부터 순차적으로 처리해야 하기 때문에 리스트를 사용해 queue 로 활용함. 
2. 모든 기능들이 개발이 완료될 때까지 반복해야 하기 때문에 while문과 len() 사용 
3. 해당 기능이 개발 과정 측정을 위해 time 변수를 사용해야 함.
4. 완료가 된다면 다음 기능 개발을 위해 progresses와 speeds의 값을 제거해주고, 
   배포를 위해 count에 1을 더해줌.
5. 기능이 미완성인 경우엔 time에 1을 더해줌.
6. 앞의 기능 개발이 동시다발적으로 완성되었지만, 다음 기능으로 넘어갔는데 미완성일 경우 
   완성된 기능들은 먼저 배포를 해주기 위해 count > 0: answer 변수에 count를 담아주고
   다음 기능 개발을 위해 count를 초기화 시킴 

<문제 해결 위해 필요한 것 공부>
1.
파이썬에선 queue 라이브러리 제공함. 
  import queue
  data_queue = queue.Queue()

Queue 데이터 구조: 
  줄을 서는 행위와 유사함. FIFO (First In First Out), LILO(Last In Last Out)
Enqueue: 큐에 데이터 넣기
Dequeue: 큐에서 데이터 빼기
Queue(): 일반적인 큐 자료
LifoQueue(): 스택과 유사 방식. LIFO 구조.
PriorityQueue(): 데이터마다 우선 순위를 넣어서, 우선 순위가 높은 순으로 데이터 출력
-> 데이터 넣을 때 (우선순위, 데이터) 형식의 튜플로 넣어야 함. 
   data_queue.put((10, "korea)) 
   data_queue.put((5, 1))
-> 데이터 꺼낼 때 
   data_queue.get() # 우선순위가 높은 (값이 가장 낮은) 데이터 순 출력: (5,1)

2. for 문 & while 문
for 문은 반복해야할 횟수를 알 때 사용함
반면, while 문은 반복 횟수는 모르지만 종료 조건을 알 때 사용함. 

<문제 풀이 시도>

import queue
def solution(progresses, speeds): # solution의 매개변수 progresses, speeds
    answer = []
    count = 0
    data_queue = queue.Queue()
    data_queue.put(progresses)
    while progresses < 100:
        progresses = progresses + speeds
        count += 1
    answer.append(count)
    return answer
    
progresses가 순차적으로 출력되어야 한다고 생각해서 queue의 fifo 특성을 사용하려고 했음.
그러나 progress가 100이 되었을 때까지 소요된 시간을 그 다음 progress에 어떻게 연결시켜야 할지 알아내지 못함.
그리고 출력해야하는 건 배포할 기능의 개수인데 이 또한 어떻게 해야할지 몰랐음.

<구글링 후 문제 풀이>

def solution(progresses, speeds): # solution의 매개변수 progresses, speeds
    # list를 사용하면 뒤에서 fifo 방식으로 데이터를 사용할 수 있어서 queue 자료 구조를 사용하는 효과가 남.
    answer = []
    time = 0
    count = 0
    while len(progresses) > 0 : # 모든 기능들이 개발 완료될 때까지 반복
        if ((progresses[0] + time*speeds[0])  >= 100) : # time을 늘려주기 때문에 누적합은 필요 없음, 첫 번째 기능부터 순선대로 처리하면 되기 때문에 [0] 사용 
            progresses.pop[0]
            speeds.pop[0]
            count += 1
    else: # 그 다음 기능은 완성되지 못해 앞의 기능들과 함께 배포 되지 못할 경우엔 완성된 기능만 배포해 줌
        if count > 0:
            answer.append(count)
            count = 0
        time += 1 # 기능이 미완성일 경우에는 time을 늘려줘야 함
    answer.append(count)
    return answer
 
-------------------------------------------------------------------------

성욱님 풀이

def solution(progresses, speeds):
    dates = []
    for progress, speed in zip(progresses, speeds):  # zip 함수 사용 (progress, speed) ex:(93,1)
        date = 0
        while True:
            progress += speed  # progress에 speed를 더해줌
            date += 1  # date 변수에 시간은 따로 계산해 줌
            if progress >= 100:  # 기능이 완성되었을 경우 break
                break
        dates.append(date)  # 누적된 시간은 dates라는 변수에 저장 ex: 7

    answer = []
    cnt = 1
    for i in range(1, len(dates)): # 일수 만큼 반복  
        if dates[i] <= dates[i - 1]: # dates[1] <= dates[0] ex: [7, 1, 4]
            dates[i] = dates[i - 1] # dates [1] = dates [0] 원소의 값들을 앞에서부터 순차적으로 비교해서 앞의 기능의 배포 날짜에 맞춰줌 
            cnt += 1 # 동일한 배포 날짜면 +1 
        else: # 그렇지 않은 경우는 위에 cnt 변수를 1로 선언해줬으니 그 값을 출력하고 다시 cnt 를 1로 초기화시킴 
            answer.append(cnt)
            cnt = 1
    answer.append(cnt)
    
 
----------------------------------------------------------------------------------------------------

유성님 풀이

from collections import deque # deque 사용
from math import ceil

def solution(progresses, speeds):
    RATE = 0
    SPEED = 1
    dq = deque(list((rate, speed) 
      for rate, speed in zip(progresses, speeds))) # progresses, speeds를 zip으로 묶은 다음, 그걸 각각 rate, speed 변수에 넣고 그걸 deque 성격의 2차원 list로 만든거인듯
      # dq = deque[[rate, speed],[rate, speed],[rate, speed]]
    time = 0
    answer = []
    while dq:
        cnt_deploy = 0 # 배포 건수 세는 변수 
        curr_rate = dq[0][RATE] + time * dq[0][SPEED] # 현재 진행 비율 계산: dq[0][RATE = 0 ] = 93 + time*dq[0][SPEED = 1] = 1
        if curr_rate < 100: # 현재 비율이 100 미만일 때 
            time += ceil((100 - curr_rate) / dq[0][SPEED]) # 기능 개발 소요 시간 계산  # math.ceil(): 실수 입력시 올림 후 정수 반환 
        
        while dq and dq[0][RATE] + time * dq[0][SPEED] >= 100: # 기능 개발 완료시 
            dq.popleft() # 앞에서부터 원소 제거 
            cnt_deploy += 1 # 배포 횟수 1 추가 
            
        answer.append(cnt_deploy)
    return answer
