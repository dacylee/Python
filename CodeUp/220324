#6093

<문제 해석>
입력받은 번호를 거꾸로 출력해야 함 

문제 풀이 방법 고안:
1. 번호 부른 순서를 리스트에 순서대로 기록해둔 뒤 그 값들을 거꾸로 출력
2. 스택 사용(Last In First Out: LIFO 구조)
   1) 빈 리스트 만들어줌
   2) 원소 넣을 때 append 메서드 사용: 리스트의 가장 마지막에 원소 넣음
   3) 원소 뺄 때 pop 메서드 사용: 리스트의 가장 마지막 원소 제거 후 리턴 
   4) 제거하지 않고 가져오기만 하려면 [-1] 사용

<문제 풀이 1>
 
N = int(input())
stack=[]
stack = map(int, input().split())
for i in range(N):
  print(stack[-1], end=' ')
  
* 궁금한 점: stack에 있는 원소를 연속적으로 나열해서 출력할 수는 없는건지? 
** 아래와 같이 해결: 
   1) list(map()) 을 해줘야 함
   2) stack[-1]을 해주면 원소가 사라지지 않아서 한 원소만 계속 출력됨
   3) pop()을 사용해주면 맨 뒤의 원소부터 하나씩 처리됨 

N = int(input())
stack = list(map(int, input().split()))
for i in range(N):
  print(stack.pop(), end=' ')

<문제 풀이 2>

for i in range(n-1, -1, -1): # range(시작, 끝, 증감) -> 이때 시작 수는 포함하나 끝 수는 포함하지 않음 
  print(a[i], end=' ')
 # n-1, n-2, ... , 0 

n = int(input())
a = list(map(int, input().split()))
for i in range(n-1, -1, -1):
    print(a[i], end=' ')
    
** 계속 틀린 이유: map 함수를 이용해서 값들을 입력받고 list에 넣고 싶으면 list(map()) 임


------------------------------------------------------------------------------------------

# 6094

<문제 해석>

리스트 안의 가장 작은 값을 출력

<문제 풀이 고안>

1) heap 배열을 사용해 가장 작은 값을 찾아낸다
2) 변수에 첫 원소를 저장해 두고 그 다음 원소랑 비교한다.
   그 다음 원소가 더 작을 시 그 원소를 변수에 저장한 뒤 그 다음 원소랑 비교한다.
   마지막 원소까지 이 과정을 반복한다.
   
   예시:
    a = k[0]
    k[0] > k[1] -> a = k[1]
    k[1] > k[2] -> a = k[2] 

<문제 풀이 1>

import heapq

n = int(input())
k = list(map(int, input().split()))
heapq.heapify(k)
print(k[0])

<문제 풀이 2>

n = int(input())
k = list(map(int, input().split()))
a = k[0]
for i in range(n):
  if (a>k[i]):
    a = k[i]
 print(a)



